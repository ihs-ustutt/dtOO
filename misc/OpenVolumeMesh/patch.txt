Index: src/OpenVolumeMesh/Core/BaseProperty.hh
===================================================================
--- src/OpenVolumeMesh/Core/BaseProperty.hh	(revision 267)
+++ src/OpenVolumeMesh/Core/BaseProperty.hh	(working copy)
@@ -46,6 +46,8 @@
 #include <string>
 
 #include "OpenVolumeMeshHandle.hh"
+#include <ostream>
+#include <istream>
 
 namespace OpenVolumeMesh {
 
@@ -100,6 +102,27 @@
     bool lock_;
 };
 
+template<class T> 
+std::ostream& operator<<(std::ostream& _os, const std::vector< T >& _prop) {
+  _os << _prop.size();
+  for (int ii=0; ii<_prop.size(); ii++) {
+    _os << std::endl << _prop[ii];
+  }
+  return _os;
+};
+
+template<class T> 
+std::istream& operator>>(std::istream& _istr, std::vector< T >& _prop) {
+  int nProps;
+  _istr >> nProps;
+  for (int ii=0; ii<nProps; ii++) {
+    T val;
+    _istr >> val;
+    _prop.push_back( val );
+  }
+  return _istr;
+};
+
 } // Namespace OpenVolumeMesh
 
 #endif /* BASEPROPERTY_HH_ */
Index: src/OpenVolumeMesh/Core/Iterators.cc
===================================================================
--- src/OpenVolumeMesh/Core/Iterators.cc	(revision 267)
+++ src/OpenVolumeMesh/Core/Iterators.cc	(working copy)
@@ -440,6 +440,200 @@
 }
 
 ////================================================================================================
+//// VertexVertexIter
+////================================================================================================
+
+VertexVertexIter::VertexVertexIter(const VertexHandle& _ref_h,
+        const TopologyKernel* _mesh, int _max_laps) :
+BaseIter(_mesh, _ref_h, _max_laps) {
+
+	if(!_mesh->has_full_bottom_up_incidences()) {
+#ifndef NDEBUG
+        std::cerr << "This iterator needs bottom-up incidences!" << std::endl;
+#endif
+        BaseIter::valid(false);
+        return;
+    }
+
+    if((unsigned int)_ref_h.idx() >= BaseIter::mesh()->outgoing_hes_per_vertex_.size()) {
+        BaseIter::valid(false);
+        return;
+    }
+
+    // Build up vertices list
+    const std::vector<HalfEdgeHandle>& incidentHalfedges = BaseIter::mesh()->outgoing_hes_per_vertex_[_ref_h.idx()];
+    for(std::vector<HalfEdgeHandle>::const_iterator it = incidentHalfedges.begin(); it != incidentHalfedges.end(); ++it) {
+
+    	if(*it < 0 || (unsigned int)it->idx() >= BaseIter::mesh()->incident_hfs_per_he_.size()) continue;
+      if ( mesh()->halfedge(*it).from_vertex() == _ref_h ) {
+        vertices_.push_back( mesh()->halfedge(*it).to_vertex() );
+      }
+      else {
+        vertices_.push_back( mesh()->halfedge(*it).from_vertex() );
+      }
+    }
+    
+    // Remove all duplicate entries
+    std::sort(vertices_.begin(), vertices_.end());
+    vertices_.resize(std::unique(vertices_.begin(), vertices_.end()) - vertices_.begin());
+
+    cur_index_ = 0;
+    BaseIter::valid(vertices_.size()>0);
+    if(BaseIter::valid()) {
+        BaseIter::cur_handle(vertices_[cur_index_]);
+    }
+}
+
+VertexVertexIter& VertexVertexIter::operator--() {
+
+    if(cur_index_ == 0) {
+        cur_index_ = vertices_.size()-1;
+        --lap_;
+        if (lap_ < 0) {
+            BaseIter::valid(false);
+        }
+    } else {
+        --cur_index_;
+    }
+
+    BaseIter::cur_handle(vertices_[cur_index_]);
+    return *this;
+}
+
+
+VertexVertexIter& VertexVertexIter::operator++() {
+
+    ++cur_index_;
+    if(cur_index_ == vertices_.size()) {
+        cur_index_ = 0;
+        ++lap_;
+        if (lap_ >= max_laps_) {
+            BaseIter::valid(false);
+        }
+	}
+    BaseIter::cur_handle(vertices_[cur_index_]);
+	return *this;
+}
+
+////================================================================================================
+//// CellHalfFaceIter
+////================================================================================================
+
+
+CellHalfFaceIter::CellHalfFaceIter(const CellHandle& _ref_h,
+        const TopologyKernel* _mesh, int _max_laps) :
+BaseIter(_mesh, _ref_h, _max_laps) {
+
+    std::vector<HalfFaceHandle>::const_iterator hf_iter = BaseIter::mesh()->cell(_ref_h).halffaces().begin();
+    for(; hf_iter != BaseIter::mesh()->cell(_ref_h).halffaces().end(); ++hf_iter) {
+            incident_halffaces_.push_back(*hf_iter);
+    }
+
+    cur_index_ = 0;
+    BaseIter::valid(incident_halffaces_.size() > 0);
+
+    if(BaseIter::valid()) {
+        BaseIter::cur_handle(incident_halffaces_[cur_index_]);
+    }
+}
+
+
+CellHalfFaceIter& CellHalfFaceIter::operator--() {
+
+    if (cur_index_ == 0) {
+        cur_index_ = incident_halffaces_.size()-1;
+        --lap_;
+        if (lap_ < 0)
+            BaseIter::valid(false);
+    }
+    else {
+        --cur_index_;
+    }
+
+    BaseIter::cur_handle(incident_halffaces_[cur_index_]);
+    return *this;
+}
+
+
+CellHalfFaceIter& CellHalfFaceIter::operator++() {
+
+    ++cur_index_;
+    if (cur_index_ == incident_halffaces_.size()){
+        cur_index_ = 0;
+        ++lap_;
+        if (lap_ >= max_laps_)
+            BaseIter::valid(false);
+    }
+
+    BaseIter::cur_handle(incident_halffaces_[cur_index_]);
+	return *this;
+}
+
+////================================================================================================
+//// CellHalfEdgeIter
+////================================================================================================
+
+
+CellHalfEdgeIter::CellHalfEdgeIter(const CellHandle& _ref_h,
+        const TopologyKernel* _mesh, int _max_laps) :
+BaseIter(_mesh, _ref_h, _max_laps) {
+
+    std::vector<HalfFaceHandle>::const_iterator hf_iter = BaseIter::mesh()->cell(_ref_h).halffaces().begin();
+    for(; hf_iter != BaseIter::mesh()->cell(_ref_h).halffaces().end(); ++hf_iter) {
+        FaceHandle fH = BaseIter::mesh()->face_handle(*hf_iter);
+        std::vector<HalfEdgeHandle>::const_iterator he_iter 
+        = 
+        BaseIter::mesh()->face(fH).halfedges().begin();
+        for(; he_iter != BaseIter::mesh()->face(fH).halfedges().end(); ++he_iter) {
+            incident_halfedges_.push_back(*he_iter);
+      }
+    }
+
+    // Remove all duplicate entries
+    std::sort(incident_halfedges_.begin(), incident_halfedges_.end());
+    incident_halfedges_.resize(std::unique(incident_halfedges_.begin(), incident_halfedges_.end()) - incident_halfedges_.begin());
+    
+    cur_index_ = 0;
+    BaseIter::valid(incident_halfedges_.size() > 0);
+
+    if(BaseIter::valid()) {
+        BaseIter::cur_handle(incident_halfedges_[cur_index_]);
+    }
+}
+
+
+CellHalfEdgeIter& CellHalfEdgeIter::operator--() {
+
+    if (cur_index_ == 0) {
+        cur_index_ = incident_halfedges_.size()-1;
+        --lap_;
+        if (lap_ < 0)
+            BaseIter::valid(false);
+    }
+    else {
+        --cur_index_;
+    }
+
+    BaseIter::cur_handle(incident_halfedges_[cur_index_]);
+    return *this;
+}
+
+
+CellHalfEdgeIter& CellHalfEdgeIter::operator++() {
+
+    ++cur_index_;
+    if (cur_index_ == incident_halfedges_.size()){
+        cur_index_ = 0;
+        ++lap_;
+        if (lap_ >= max_laps_)
+            BaseIter::valid(false);
+    }
+
+    BaseIter::cur_handle(incident_halfedges_[cur_index_]);
+	return *this;
+}
+
+////================================================================================================
 //// CellCellIter
 ////================================================================================================
 
Index: src/OpenVolumeMesh/Core/Iterators.hh
===================================================================
--- src/OpenVolumeMesh/Core/Iterators.hh	(revision 267)
+++ src/OpenVolumeMesh/Core/Iterators.hh	(working copy)
@@ -507,6 +507,188 @@
 
 //===========================================================================
 
+//===========================================================================
+
+//===========================================================================
+
+class VertexVertexIter : public BaseCirculator<
+	VertexHandle,
+	VertexHandle> {
+public:
+    typedef BaseCirculator<
+			VertexHandle,
+			VertexHandle> BaseIter;
+
+    VertexVertexIter(const VertexHandle& _vIdx, const TopologyKernel* _mesh, int _max_laps = 1);
+
+	// Post increment/decrement operator
+	VertexVertexIter operator++(int) {
+		VertexVertexIter cpy = *this;
+		++(*this);
+		return cpy;
+	}
+	VertexVertexIter operator--(int) {
+		VertexVertexIter cpy = *this;
+		--(*this);
+		return cpy;
+	}
+	VertexVertexIter operator+(int _n) {
+		VertexVertexIter cpy = *this;
+		for(int i = 0; i < _n; ++i) {
+			++cpy;
+		}
+		return cpy;
+	}
+	VertexVertexIter operator-(int _n) {
+		VertexVertexIter cpy = *this;
+		for(int i = 0; i < _n; ++i) {
+			--cpy;
+		}
+		return cpy;
+	}
+	VertexVertexIter& operator+=(int _n) {
+		for(int i = 0; i < _n; ++i) {
+			++(*this);
+		}
+		return *this;
+	}
+	VertexVertexIter& operator-=(int _n) {
+		for(int i = 0; i < _n; ++i) {
+			--(*this);
+		}
+		return *this;
+	}
+
+	VertexVertexIter& operator++();
+	VertexVertexIter& operator--();
+
+private:
+    std::vector<VertexHandle> vertices_;
+    size_t cur_index_;
+};
+
+//===========================================================================
+        
+//===========================================================================
+
+class CellHalfFaceIter : public BaseCirculator<
+	CellHandle,
+	HalfFaceHandle> {
+public:
+    typedef BaseCirculator<
+			CellHandle,
+			HalfFaceHandle> BaseIter;
+
+    CellHalfFaceIter(const CellHandle& _cIdx, const TopologyKernel* _mesh, int _max_laps = 1);
+
+	// Post increment/decrement operator
+	CellHalfFaceIter operator++(int) {
+		CellHalfFaceIter cpy = *this;
+		++(*this);
+		return cpy;
+	}
+	CellHalfFaceIter operator--(int) {
+		CellHalfFaceIter cpy = *this;
+		--(*this);
+		return cpy;
+	}
+	CellHalfFaceIter operator+(int _n) {
+		CellHalfFaceIter cpy = *this;
+		for(int i = 0; i < _n; ++i) {
+			++cpy;
+		}
+		return cpy;
+	}
+	CellHalfFaceIter operator-(int _n) {
+		CellHalfFaceIter cpy = *this;
+		for(int i = 0; i < _n; ++i) {
+			--cpy;
+		}
+		return cpy;
+	}
+	CellHalfFaceIter& operator+=(int _n) {
+		for(int i = 0; i < _n; ++i) {
+			++(*this);
+		}
+		return *this;
+	}
+	CellHalfFaceIter& operator-=(int _n) {
+		for(int i = 0; i < _n; ++i) {
+			--(*this);
+		}
+		return *this;
+	}
+
+	CellHalfFaceIter& operator++();
+	CellHalfFaceIter& operator--();
+
+private:
+	std::vector<HalfFaceHandle> incident_halffaces_;
+    size_t cur_index_;
+};
+
+//===========================================================================
+
+//===========================================================================
+
+class CellHalfEdgeIter : public BaseCirculator<
+	CellHandle,
+	HalfEdgeHandle> {
+public:
+    typedef BaseCirculator<
+			CellHandle,
+			HalfEdgeHandle> BaseIter;
+
+    CellHalfEdgeIter(const CellHandle& _cIdx, const TopologyKernel* _mesh, int _max_laps = 1);
+
+	// Post increment/decrement operator
+	CellHalfEdgeIter operator++(int) {
+		CellHalfEdgeIter cpy = *this;
+		++(*this);
+		return cpy;
+	}
+	CellHalfEdgeIter operator--(int) {
+		CellHalfEdgeIter cpy = *this;
+		--(*this);
+		return cpy;
+	}
+	CellHalfEdgeIter operator+(int _n) {
+		CellHalfEdgeIter cpy = *this;
+		for(int i = 0; i < _n; ++i) {
+			++cpy;
+		}
+		return cpy;
+	}
+	CellHalfEdgeIter operator-(int _n) {
+		CellHalfEdgeIter cpy = *this;
+		for(int i = 0; i < _n; ++i) {
+			--cpy;
+		}
+		return cpy;
+	}
+	CellHalfEdgeIter& operator+=(int _n) {
+		for(int i = 0; i < _n; ++i) {
+			++(*this);
+		}
+		return *this;
+	}
+	CellHalfEdgeIter& operator-=(int _n) {
+		for(int i = 0; i < _n; ++i) {
+			--(*this);
+		}
+		return *this;
+	}
+
+	CellHalfEdgeIter& operator++();
+	CellHalfEdgeIter& operator--();
+
+private:
+	std::vector<HalfEdgeHandle> incident_halfedges_;
+    size_t cur_index_;
+};
+
+//===========================================================================
+
 class CellCellIter : public BaseCirculator<
 	CellHandle,
 	CellHandle> {
Index: src/OpenVolumeMesh/Core/PropertyDefines.cc
===================================================================
--- src/OpenVolumeMesh/Core/PropertyDefines.cc	(revision 267)
+++ src/OpenVolumeMesh/Core/PropertyDefines.cc	(working copy)
@@ -55,5 +55,8 @@
 template <> const std::string typeName<float>() { return "float"; }
 template <> const std::string typeName<double>() { return "double"; }
 template <> const std::string typeName<std::string>() { return "string"; }
+template <> const std::string typeName< std::vector< std::string > >() { return "vector<string>"; }
+template <> const std::string typeName< std::vector< int > >() { return "vector<int>"; }
+template <> const std::string typeName< std::vector< float > >() { return "vector<float>"; }
 
 } // Namespace OpenVolumeMesh
Index: src/OpenVolumeMesh/Core/PropertyDefines.hh
===================================================================
--- src/OpenVolumeMesh/Core/PropertyDefines.hh	(revision 267)
+++ src/OpenVolumeMesh/Core/PropertyDefines.hh	(working copy)
@@ -72,6 +72,7 @@
 template <> const std::string typeName<float>();
 template <> const std::string typeName<double>();
 template <> const std::string typeName<std::string>();
+template <> const std::string typeName< std::vector< std::string > >();
 
 /// Property classes for the different entity types
 template<class T>
Index: src/OpenVolumeMesh/Core/TopologyKernel.hh
===================================================================
--- src/OpenVolumeMesh/Core/TopologyKernel.hh	(revision 267)
+++ src/OpenVolumeMesh/Core/TopologyKernel.hh	(working copy)
@@ -89,6 +89,9 @@
     friend class VertexCellIter;
     friend class HalfEdgeCellIter;
     friend class CellVertexIter;
+    friend class VertexVertexIter;
+    friend class CellHalfFaceIter;
+    friend class CellHalfEdgeIter;
     friend class CellCellIter;
     friend class HalfFaceVertexIter;
     friend class BoundaryHalfFaceHalfFaceIter;
@@ -158,6 +161,18 @@
         return CellVertexIter(_h, this, _max_laps);
     }
 
+    VertexVertexIter vv_iter(const VertexHandle& _h, int _max_laps = 1) const {
+        return VertexVertexIter(_h, this, _max_laps);
+    }
+    
+    CellHalfFaceIter chf_iter(const CellHandle& _h, int _max_laps = 1) const {
+        return CellHalfFaceIter(_h, this, _max_laps);
+    }
+
+    CellHalfEdgeIter che_iter(const CellHandle& _h, int _max_laps = 1) const {
+        return CellHalfEdgeIter(_h, this, _max_laps);
+    }        
+
     std::pair<CellVertexIter, CellVertexIter> cell_vertices(const CellHandle& _h, int _max_laps = 1) const {
         CellVertexIter begin = cv_iter(_h, _max_laps);
         return std::make_pair(begin, make_end_circulator(begin));
Index: src/OpenVolumeMesh/FileManager/FileManagerT.cc
===================================================================
--- src/OpenVolumeMesh/FileManager/FileManagerT.cc	(revision 267)
+++ src/OpenVolumeMesh/FileManager/FileManagerT.cc	(working copy)
@@ -336,7 +336,10 @@
     else if(prop_t == typeName<float>()) generateGenericProperty<float, MeshT>(entity_t, name, _iff, _mesh);
     else if(prop_t == typeName<double>()) generateGenericProperty<double, MeshT>(entity_t, name, _iff, _mesh);
     else if(prop_t == typeName<std::string>()) generateGenericProperty<std::string, MeshT>(entity_t, name, _iff, _mesh);
-
+    else if(prop_t == typeName< std::vector< std::string > >()) generateGenericProperty< std::vector< std::string >, MeshT>(entity_t, name, _iff, _mesh);
+    else if(prop_t == typeName< std::vector< int > >()) generateGenericProperty< std::vector< int >, MeshT>(entity_t, name, _iff, _mesh);
+    else if(prop_t == typeName< std::vector< float > >()) generateGenericProperty< std::vector< float >, MeshT>(entity_t, name, _iff, _mesh);
+    
     else if(prop_t == typeName<Vec2f>()) generateGenericProperty<Vec2f, MeshT>(entity_t, name, _iff, _mesh);
     else if(prop_t == typeName<Vec2d>()) generateGenericProperty<Vec2d, MeshT>(entity_t, name, _iff, _mesh);
     else if(prop_t == typeName<Vec2i>()) generateGenericProperty<Vec2i, MeshT>(entity_t, name, _iff, _mesh);
